% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/get_1_PM_mean_z_score.R
\name{get_1_PM_mean_z_score}
\alias{get_1_PM_mean_z_score}
\title{One permutation mean z-score}
\usage{
get_1_PM_mean_z_score(y_mat, trt)
}
\arguments{
\item{y_mat}{Numeric matrix (or coercible to matrix) of outcomes with
\code{n} rows (subjects) and \code{K} columns (endpoints).}

\item{trt}{Integer or numeric vector of length \code{n} giving the original
treatment indicator (e.g. 1 = treatment, 0 = control).}
}
\value{
A single numeric value: the permuted mean z-score.
}
\description{
This helper performs \strong{one} permutation step for the permutation test
described in Li et al. (2020).
}
\details{
\enumerate{
\item randomly permutes the treatment indicator,
\item for \strong{each endpoint} runs a two-sample \code{t.test()},
\item takes the \emph{negative} of the test statistic (to match the direction in
the interim code),
\item returns the \strong{mean} of those endpointwise test statistics.
}
}
\examples{
\dontrun{
y_mat1   <- rbind(y_trt1, y_ct1)
trt_ind1 <- rep(c(1, 0), c(n_trt1, n_ct1))
mean_z_score <- mean(apply(y_mat1, 2, function(y) {
  -as.numeric(stats::t.test(y ~ trt_ind1)$statistic)}))
perm_mean <- rep(NA, nPM)
for (pm in seq_len(nPM)) {
  perm_mean[pm] <- get_1_PM_mean_z_score(y_mat = y_mat1, trt = trt_ind1)
}
p_value1          <- mean(perm_mean > mean_z_score)
test_stat_interim <- stats::qnorm(1 - p_value1)
}

}
